#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (C) 2021 Petter Reinholdtsen <pere@hungry.com>
#
# Licensed under the GNU General Public License Version 2
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

from __future__ import print_function

import copy
import sys
import os
import urllib
from urllib.parse import urlparse
sys.path.append(os.path.join(sys.path[0],'lib'))

import argparse
import datetime
import json
import pytz
import n5core.endpoint
import six
from n5core.endpoint import HTTPError
import codecs
from xml.sax.saxutils import escape


# This list is provided to work around the stupidity in ยง 5-31 of
# <URL: https://lovdata.no/dokument/SF/forskrift/2017-12-19-2286 >,
# which state "Filformat for arkivdokumenter angis ved filendelse,
# f.eks. XML, PDF eller TIF.", ignoring the fact that file endings is
# a useless format specifier (which is obvious from looking at the
# many duplicates in this list), and that a proper format is specified
# in the XML file using the <format> tag.
# This list is based on
# <URL: https://codeberg.org/noark/m701-noark5-katalog >.
formatsuffix = {
    'fmt/100': 'html',
    'fmt/101': 'xml',
    'fmt/1011': 'xml',
    'fmt/103': 'html',
    'fmt/1047': 'gml',
    'fmt/1189': 'xml',
    'fmt/120': 'xml',
    'fmt/121': 'xml',
    'fmt/1246': 'sosi',
    'fmt/1247': 'sosi',
    'fmt/1248': 'sosi',
    'fmt/1249': 'sosi',
    'fmt/1250': 'sosi',
    'fmt/13': 'png',
    'fmt/134': 'mp3',
    'fmt/136': 'odt',
    'fmt/137': 'ods',
    'fmt/138': 'odp',
    'fmt/155': 'tiff',
    'fmt/156': 'tiff',
    'fmt/199': 'mp4',
    'fmt/206': 'sql',
    'fmt/214': 'xlsx',
    'fmt/215': 'pptx',
    'fmt/278': 'mbox',
    'fmt/279': 'flac',
    'fmt/289': 'warc',
    'fmt/290': 'odt',
    'fmt/291': 'odt',
    'fmt/292': 'odp',
    'fmt/293': 'odp',
    'fmt/294': 'ods',
    'fmt/295': 'ods',
    'fmt/353': 'tiff',
    'fmt/354': 'pdf',
    'fmt/41': 'jpeg',
    'fmt/412': 'docx',
    'fmt/42': 'jpeg',
    'fmt/425': 'mpeg2',
    'fmt/43': 'jpeg',
    'fmt/44': 'jpeg',
    'fmt/471': 'html',
    'fmt/494': 'docx',
    'fmt/494': 'pptx',
    'fmt/494': 'xlsx',
    'fmt/640': 'mpeg2',
    'fmt/659': 'ifc',
    'fmt/664': 'ifc',
    'fmt/699': 'ifc',
    'fmt/700': 'ifc',
    'fmt/703': 'wav',
    'fmt/704': 'wav',
    'fmt/705': 'wav',
    'fmt/896': 'xml',
    'fmt/95': 'pdf',
    'fmt/950': 'mbox',
    'fmt/96': 'html',
    'fmt/97': 'html',
    'fmt/98': 'html',
    'fmt/99': 'html',
    'x-fmt/111': 'txt',
    'x-fmt/18': 'csv',
    'x-fmt/227': 'gml',
    'x-fmt/263': 'zip',
    'x-fmt/265': 'tar',
    'x-fmt/392': 'jpeg2000',
}

def sha256_of_file(filename):
    from hashlib import sha256
    hasher = sha256()
    mv = memoryview(bytearray(128*1024))
    with open(filename, 'rb', buffering=0) as f:
        while n := f.readinto(mv):
            hasher.update(mv[:n])
    return hasher.hexdigest()


def utcnowtz():
    u = datetime.datetime.utcnow()
    u = u.replace(tzinfo=pytz.utc)
    return u


class XMLTag(object):
    def __init__(self, level, fh, tagname, attr=None):
        self.fh = fh
        self.tagname = tagname
        self.attr = attr
        self.level = level


    def __enter__(self):
        if self.attr:
            attr = " " + str.join(" ",
                                  ['%s="%s"' % (i[0], i[1])
                                   for i in self.attr.items()])
        else:
            attr = ""
        self.fh.write('%s<%s%s>\n' % ('  ' * self.level[0], self.tagname, attr))
        self.level[0] +=1


    def __exit__(self, tpe, value, traceback):
        self.level[0] -=1
        self.fh.write('%s</%s>\n' % ('  ' * self.level[0], self.tagname))


class XMLFile(object):
    def __init__(self, fh):
        self.level = [0] # Using ref to allow XMLTag to update the value
        self.fh = fh
        fh.write('<?xml version="1.0" encoding="UTF-8"?>\n')


    def tag(self, name, attr=None):
        return XMLTag(self.level, self.fh, name, attr=attr)


    def write(self, s):
        return self.fh.write(s)


    def writetag(self, tagname, s=None, attr=None):
        if isinstance(s, six.text_type):
            s = escape(s)
        if attr:
            attr = " " + str.join(" ",
                                  ['%s="%s"' % (i[0], i[1])
                                   for i in attr.items()])
        else:
            attr = ""
        if s:
            self.fh.write('%s<%s%s>%s</%s>\n' % ('  ' * self.level[0], tagname, attr, s, tagname))
        elif '' != attr: # Skip these, ref. Noark 6.4.5
            self.fh.write('%s<%s%s/>\n' % ('  ' * self.level[0], tagname, attr))
    @staticmethod
    def bool2str(istrue):
        if istrue:
            return "true"
        return "false"

class ContentDumper(n5core.endpoint.Endpoint):
    def __init__(self):
        self.baseurl = 'http://localhost:8092/noark5v5/'
        utcnow = datetime.datetime.utcnow().replace(microsecond=0, tzinfo=pytz.utc)
        self.savedir = 'json-dump-%s' % utcnow.isoformat()
        parser = argparse.ArgumentParser()
        parser.add_argument('--baseurl', help='(default is %s)' % self.baseurl)
        parser.add_argument('--xml', help='(default is false)',
                            default=False, action='store_true')
        parser.add_argument('--savedir', help='(default is %s)' % self.savedir)
        parser.add_argument('--verbose', help='enable debug output',
                            action='store_true')
        parser.add_argument('--onlyclosed', help='only export closed entities',
                            action='store_true')
        parser.add_argument('--xml-extended', help='enable extended (aka non-official) XML output',
                            action='store_true')
        self.args = parser.parse_args()
        if self.args.baseurl:
            self.baseurl = self.args.baseurl
        if self.args.savedir:
            self.savedir = self.args.savedir
        n5core.endpoint.Endpoint.__init__(self,self.baseurl)
        self.verbose = self.args.verbose
        self.xml = self.args.xml
        self.xml_extended = self.args.xml_extended

        self.forfatterrel = '%sforfatter/' % self.nikitarelbaseurl
        self.noekkelordrel = '%snoekkelord/' % self.nikitarelbaseurl
        self.oppbevrel = '%soppbevaringssted/' % self.nikitarelbaseurl
        self.screeningmetadatarel = '%sskjermingmetadata/' % self.nikitarelbaseurl

        self.stats = {}
        self.files = {}
        self.schemas = {}


    def stats_add(self, entity):
        if entity not in self.stats:
            self.stats[entity] = 0
        self.stats[entity] += 1

    def stats_get(self, entity):
        if entity in self.stats:
            return self.stats[entity]
        return 0

    def _mkdir_recursive(self, path):
        sub_path = os.path.dirname(path)
        if '' != sub_path and not os.path.exists(sub_path):
            self._mkdir_recursive(sub_path)
        if not os.path.exists(path):
            os.mkdir(path)



    def recurse_xml_out_ordered(self, output, entity, content, sequence, attr=None):
        with output.tag(entity, attr=attr):
#            if self.verbose:
#                print(content)
            for k in sequence:
                keytype = type(k)
                if str == keytype:
                    if -1 != k.find('>'):
                        f, t = k.split('>')
                        if -1 != f.find('.'):
                            a, b = f.split('.')
                            if a in content and b in content[a]:
                                if '[null]' != t:
                                    output.writetag(t, content[a][b])
                                del content[a][b]
                                if not content[a].keys():
                                    del content[a]
                        else:
                            if f in content:
                                if '[null]' != t:
                                    output.writetag(t, content[f])
                                del content[f]
                    else:
                        if k in content:
                            output.writetag(k, content[k])
                            del content[k]
                elif tuple == keytype:
                    rel = k[0]
                    if rel in content['_links']:
                        urls = [ content['_links'][rel]['href'] ]
                        while urls:
                            url = urls.pop()
                            if 'templated' in content['_links'][rel] \
                               and content['_links'][rel]['templated']:
                                url = url.split('{')[0]
                            if 2 < len(k):
                                url += k[2] # Add filter if present
                            (c, res) = self.json_get(url)
                            info = json.loads(c)
                            # Process list if relation gave non-empty result
                            if ('count' in info and 0 < info['count']) \
                               or 'results' in info:
                                for sub in info['results']:
                                    k[1](output, sub)
                                if 'next' in info['_links']:
                                    nexturl = info['_links']['next']['href']
                                    urls.append(nexturl)
                            elif not 'count' in info:
                                print('warning: GET %s did not return list' % (url))
                                k[1](output, info)
                    elif rel in content:
                        k[1](output, content[rel], content)
                        del content[rel]
            if '_links' in content:
                del content['_links']
            if content.keys():
                print('warning: %s XML attribute not exported: %s' % (entity, content))
        self.stats_add(entity)


    def recurse_xml_konvertering(self, output, content):
        sequence = (
            'systemID>[null]',
            'konvertertDato',
            'konvertertAv',
            'konvertertFraFormat.kodenavn>[null]',
            'konvertertFraFormat.kode>konvertertFraFormat',
            'konvertertTilFormat.kodenavn>[null]',
            'konvertertTilFormat.kode>konvertertTilFormat',
            'konverteringsverktoey',
            'konverteringskommentar'
        )
        self.recurse_xml_out_ordered(output, 'konvertering', content, sequence)


    def recurse_xml_merknad(self, output, content):
        sequence = (
            'systemID>[null]',
            'merknadstekst',
            'merknadstype.kodenavn>merknadstype',
            'merknadstype.kode>[null]',
            'merknadsdato',
            'merknadRegistrertAv'
        )
        self.recurse_xml_out_ordered(output, 'merknad', content, sequence)


    def recurse_xml_forfatter(self, output, content):
        output.writetag('forfatter', content['forfatter'])


    def recurse_xml_kassasjon(self, output, content, parent=None):
        sequence = (
            'kassasjonsvedtak.kodenavn>kassasjonsvedtak',
            'kassasjonsvedtak.kode>[null]',
            'kassasjonshjemmel',
            'bevaringstid',
            'kassasjonsdato',
        )
        self.recurse_xml_out_ordered(output, 'kassasjon', content, sequence)


    def recurse_xml_utfoertKassasjon(self, output, content, parent=None):
        sequence = (
            'kassertDato',
            'kassertAv',
        )
        self.recurse_xml_out_ordered(output, 'utfoertKassasjon', content, sequence)


    def recurse_xml_sletting(self, output, content, parent=None):
        sequence = (
            'slettingstype.kodenavn>slettingstype',
            'slettingstype.kode>[null]',
            'slettetDato',
            'slettetAv',
            #'referanseSlettetAv',
        )
        self.recurse_xml_out_ordered(output, 'sletting', content, sequence)


    def recurse_xml_skjermingmetadata(self, output, content):
        output.writetag('skjermingMetadata', content['kodenavn'])


    def recurse_xml_skjerming(self, output, content, parent=None):
        sequence = (
            'tilgangsrestriksjon.kodenavn>tilgangsrestriksjon',
            'tilgangsrestriksjon.kode>[null]',
            'skjermingshjemmel',
            (self.screeningmetadatarel, self.recurse_xml_skjermingmetadata),
            'skjermingDokument.kodenavn>skjermingDokument',
            'skjermingDokument.kode>[null]',
            'skjermingsvarighet',
            'skjermingOpphoererDato',
        )
        content['_links'] = parent['_links']
        self.recurse_xml_out_ordered(output, 'skjerming', content, sequence)


    def recurse_xml_gradering(self, output, content, parent=None):
        sequence = (
            'graderingskode.kodenavn>grad',
            'graderingskode.kode>[null]',
            'graderingsdato',
            'gradertAv',
            'nedgraderingsdato',
            'nedgradertAv',
        )
        self.recurse_xml_out_ordered(output, 'gradering', content, sequence)


    def recurse_xml_elektroniskSignatur(self, output, content, parent=None):
        sequence = (
            'elektroniskSignaturSikkerhetsnivaa.kodenavn>elektroniskSignaturSikkerhetsnivaa',
            'elektroniskSignaturSikkerhetsnivaa.kode>[null]',
            'elektroniskSignaturVerifisert.kodenavn>elektroniskSignaturVerifisert',
            'elektroniskSignaturVerifisert.kode>[null]',
            'verifisertDato',
            'verifisertAv',
        )
        self.recurse_xml_out_ordered(output, 'elektroniskSignatur', content, sequence)


    def recurse_xml_virksomhetsspesifikkeMetadata(self, output, content, parent=None):
        if not hasattr(self, 'seenvsm'):
            self.seenvsm = {}
        # Organize on namespace
        nslist = {}
        for k in content.keys():
            ns = k.split(':', 1)[0]
            if not ns in nslist:
                nslist[ns] = []
            nslist[ns].append(k)
        with output.tag('virksomhetsspesifikkeMetadata'):
            for ns in sorted(nslist.keys()):
                with output.tag(f"{ns}:{ns}"):
                    for k in sorted(nslist[ns]):
                        output.writetag(k, content[k])
                        field = k.split(':', 1)[1]
                        self.seenvsm[k] = field


    def recurse_xml_dokumentobjekt(self, output, origcontent):
        content = copy.deepcopy(origcontent)
        # Not using recurse_xml_out_ordered to handle referanseDokumentfil
        filrel = '%sarkivstruktur/fil/' % self.relbaseurl
        konvrel = '%sarkivstruktur/konvertering/' % self.relbaseurl
        sequence = [
            'systemID',
        ]
        if self.xml_extended:
            sequence.extend((
                'endretDato',
                'endretAv',
            ))
        sequence.extend((
            'versjonsnummer',
            'variantformat.kodenavn>variantformat',
            'variantformat.kode>[null]',
            'format.kodenavn>[null]',
            'format.kode>format',
            'formatDetaljer',
            'opprettetDato',
            'opprettetAv',
            'referanseDokumentfil',
            'sjekksum',
            'sjekksumAlgoritme',
            'filstoerrelse',
        ))
        if self.xml_extended:
            sequence.extend((
                'filnavn',
                'mimeType',
                ('virksomhetsspesifikkeMetadata', self.recurse_xml_virksomhetsspesifikkeMetadata),
            ))
        sequence.extend((
            ('elektroniskSignatur', self.recurse_xml_elektroniskSignatur),
            (konvrel, self.recurse_xml_konvertering),
        ))
        with output.tag('dokumentobjekt'):
            for k in sequence:
                if 'referanseDokumentfil' == k:
                    if filrel in content['_links']:
                        self._mkdir_recursive('%s/DOKUMENT' % self.savepath)
                        # Deriving filename from checksum provide
                        # automatic deduplication, assuming there is
                        # no hash collition in the dataset and
                        # consiste format string is used.
                        if 'format' in origcontent and 'kode' in origcontent['format']:
                            formatkode = origcontent['format']['kode']
                        else:
                            formatkode = 'av/0'
                        if formatkode in formatsuffix:
                            suffix = formatsuffix[formatkode]
                            print(f"warning: adding inaccurate '{suffix}' suffix to document file with format kode {formatkode}.")
                        else:
                            suffix = 'dat'
                            print(f"error: adding bogus '{suffix}' suffix to document file with unknown format kode {formatkode}.")
                        filename = '%s-%s.%s' % (content['sjekksumAlgoritme'], content['sjekksum'], suffix)
                        url = content['_links'][filrel]['href']
                        try:
                            (data, r) = self._get(url)
                            with open('%s/DOKUMENT/%s' % (
                                    self.savepath, filename), 'wb') as fh:
                                fh.write(data)
                            output.writetag('referanseDokumentfil',
                                            'DOKUMENT/%s' % filename)
                            self.stats_add('referanseDokumentfil')
                        except HTTPError as e:
                            print("error: unable to download %s: %s (%s)" % (
                                url, str(e), e.read()))
                            raise
                    continue
                keytype = type(k)
                if str == keytype:
                    if -1 != k.find('>'):
                        f, t = k.split('>')
                        if -1 != f.find('.'):
                            a, b = f.split('.')
                            if a in content and b in content[a]:
                                if '[null]' != t:
                                    output.writetag(t, content[a][b])
                                del content[a][b]
                                if not content[a].keys():
                                    del content[a]
                        else:
                            if f in content:
                                if '[null]' != t:
                                    output.writetag(t, content[f])
                                del content[f]
                    else:
                        if k in content:
                            output.writetag(k, content[k])
                            del content[k]
                elif tuple == keytype:
                    rel = k[0]
                    if rel in content['_links']:
                        url = content['_links'][rel]['href']
                        if 2 < len(k):
                            url += k[2] # Add filter if present
                        (c, res) = self.json_get(url)
                        info = json.loads(c)
                        # Process list if relation gave non-empty result
                        if ('count' in info and 0 < info['count']) \
                           or 'results' in info:
                            for sub in info['results']:
                                k[1](output, sub)
                        elif not 'count' in info:
                            print('warning: GET %s did not return list' % (url))
                            k[1](output, info)
                    elif rel in content:
                        k[1](output, content[rel], content)
                        del content[rel]
            if '_links' in content:
                del content['_links']
            if content.keys():
                print('warning: %s XML attribute not exported: %s'
                      % ('dokumentobjekt', content))
        self.stats_add('dokumentobjekt')

    def recurse_xml_dokumentbeskrivelse(self, output, content):
        partrel = '%sarkivstruktur/part/' % self.relbaseurl
        merknadrel = '%sarkivstruktur/merknad/' % self.relbaseurl
        dokobjrel = '%sarkivstruktur/dokumentobjekt/' % self.relbaseurl
        sequence = [
            'systemID',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
        ]
        if self.xml_extended:
            sequence.extend((
                'endretDato',
                'endretAv',
            ))
        sequence.extend((
            'dokumenttype.kodenavn>dokumenttype',
            'dokumenttype.kode>[null]',
            'dokumentstatus.kodenavn>dokumentstatus',
            'dokumentstatus.kode>[null]',
            'tittel',
            'beskrivelse',
            (self.forfatterrel, self.recurse_xml_forfatter),
            'opprettetDato',
            'opprettetAv',
            'dokumentmedium.kodenavn>dokumentmedium',
            'dokumentmedium.kode>[null]',
            'oppbevaringssted',
#            ('referanseArkivdel'), # FIXME for dokumentbeskrivelse
            'tilknyttetRegistreringSom.kodenavn>tilknyttetRegistreringSom',
            'tilknyttetRegistreringSom.kode>[null]',
            'dokumentnummer',
            'tilknyttetDato',
            'tilknyttetAv',
            (partrel, self.recurse_xml_part),
            (merknadrel, self.recurse_xml_merknad),
            ('kassasjon', self.recurse_xml_kassasjon),
            ('utfoertKassasjon', self.recurse_xml_utfoertKassasjon),
            ('sletting', self.recurse_xml_sletting),
            ('skjerming', self.recurse_xml_skjerming),
            ('gradering', self.recurse_xml_gradering),
            ('elektroniskSignatur', self.recurse_xml_elektroniskSignatur),
            (dokobjrel, self.recurse_xml_dokumentobjekt),
        ))
        if self.xml_extended:
            sequence.extend((
            ('virksomhetsspesifikkeMetadata', self.recurse_xml_virksomhetsspesifikkeMetadata),
            ))
        self.recurse_xml_out_ordered(output, 'dokumentbeskrivelse', content, sequence)

    def recurse_xml_national_identifier(self, output, content):
        if not self.xml_extended:
            return
        # FIXME should these be grouped?
        sequence = (
            'systemID>[null]',
            'organisasjonsnummer>organisasjonsnummer',
            'foedselsnummer>foedselsnummer',
            'dNummer>dNummer',

            'koordinatsystem.kode>koordinatsystem',
            'koordinatsystem.kodenavn>[null]',
            'x>x',
            'y>y',
            'z>z',

            'kommunenummer>kommunenummer',
            'fylkesnummer>fylkesnummer',
            'landkode.kode>[null]',
            'landkode.kodenavn>land',
            'planidentifikasjon>planidentifikasjon',

            'bygningsnummer>bygningsnummer',
            'endringsloepenummer>endringsloepenummer',

            'gaardsnummer>gaardsnummer',
            'bruksnummer>bruksnummer',
            'festenummer>festenummer',
            'seksjonsnummer>seksjonsnummer',
        )
        self.recurse_xml_out_ordered(output, 'nasjonalidentifikator', content, sequence)

    def recurse_xml_korrespondansepart(self, output, content):
        sequence = (
            'systemID>[null]',
            'korrespondanseparttype.kodenavn>korrespondanseparttype',
            'korrespondanseparttype.kode>[null]',
            'navn>korrespondansepartNavn',
            'postadresse.addresselinje1>postadresse',
            'postadresse.addresselinje2>postadresse',
            'postadresse.addresselinje3>postadresse',
            'postadresse.postnr>postnummer',
            'postadresse.poststed>poststed',
            'postadresse.landkode>land',
            'kontaktinformasjon.epostadresse>epostadresse',
            'kontaktinformasjon.mobiltelefon>telefonnummer',
            'kontaktinformasjon.telefon>telefonnummer',
            'kontaktperson',
            'administrativEnhet',
            'saksbehandler',
            ('virksomhetsspesifikkeMetadata', self.recurse_xml_virksomhetsspesifikkeMetadata),
        )
        self.recurse_xml_out_ordered(output, 'korrespondansepart', content, sequence)


    def recurse_xml_part(self, output, content):
        sequence = [
            'systemID>[null]',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
        ]
        if self.xml_extended:
            sequence.extend((
                'opprettetDato',
                'opprettetAv',
                'endretDato',
                'endretAv',
            ))
        sequence.extend((
            'navn>partNavn',
            'partRolle.kodenavn>partRolle',
            'partRolle.kode>[null]',
            'postadresse.addresselinje1>postadresse',
            'postadresse.addresselinje2>postadresse',
            'postadresse.addresselinje3>postadresse',
            'postadresse.postnr>postnummer',
            'postadresse.poststed>poststed',
            'postadresse.landkode>land',
            'kontaktinformasjon.epostadresse>epostadresse',
            'kontaktinformasjon.mobiltelefon>telefonnummer',
            'kontaktinformasjon.telefon>telefonnummer',
            'kontaktperson',
            'administrativEnhet',
            'saksbehandler',
            ('virksomhetsspesifikkeMetadata', self.recurse_xml_virksomhetsspesifikkeMetadata),
        ))
        # FIXME figure out how to handle partID
        self.recurse_xml_out_ordered(output, 'part', content, sequence)


    def recurse_xml_dokumentflyt(self, output, content):
        sequence = (
            'flytTil',
            'flytFra',
            'flytMottattDato',
            'flytSendtDato',
            'flytStatus.kodenavn>flytStatus',
            'flytStatus.kode>[null]',
            'flytMerknad',
        )
        self.recurse_xml_out_ordered(output, 'dokumentflyt', content, sequence)


    def recurse_xml_avskrivning(self, output, content):
        """
Not yet working because of
https://gitlab.com/OsloMet-ABI/nikita-noark5-core/issues/159
"""
        sequence = [
            'systemID>[null]',
            'avskrivningsdato',
            'avskrevetAv',
            'avskrivningsmaate.kodenavn>avskrivningsmaate',
            'avskrivningsmaate.kode>[null]',
            'referanseAvskrivesAvJournalpost',
        ]
        if self.xml_extended:
            sequence.extend((
                'referanseAvskrivesAvKorrespondansepart',
            ))
        self.recurse_xml_out_ordered(output, 'avskrivning', content, sequence)


    def recurse_xml_noekkelord(self, output, content):
        output.writetag('noekkelord', content['noekkelord'])


    def recurse_xml_oppbevaringssted(self, output, content):
        output.writetag('oppbevaringssted', content['oppbevaringssted'])


    def recurse_xml_kryssreferanse(self, output, content):
        print('error: "kryssreferanse" not yet implemented')


    def recurse_xml_presedens(self, output, content):
        sequence = (
            'systemID>[null]',
            'presedensDato',
            'opprettetDato',
            'opprettetAv',
            'referanseOpprettetAv>[null]',
            'tittel',
            'beskrivelse',
            'presedensHjemmel',
            'rettskildefaktor',
            'presedensGodkjentDato',
            'presedensGodkjentAv',
            'referansePresedensGodkjentAv>[null]',
            'avsluttetDato',
            'avsluttetAv',
            'referanseAvsluttetAv>[null]',
            'presedensStatus.kode>[null]',
            'presedensStatus.kodenavn>presedensStatus',
        )
        self.recurse_xml_out_ordered(output, 'presedens', content, sequence)

    def recurse_xml_registrering(self, output, content):
        entityrel = self.entity_rel(content)
        typemap = {
            '%ssakarkiv/journalpost/' % self.relbaseurl: 'journalpost',
            '%ssakarkiv/arkivnotat/' % self.relbaseurl: 'arkivnotat',
        }
        attr = None
        if entityrel in typemap:
            attr = {'xsi:type': typemap[entityrel]}
        merknadrel = '%sarkivstruktur/merknad/' % self.relbaseurl
        dokbeskrrel = '%sarkivstruktur/dokumentbeskrivelse/' % self.relbaseurl
        partrel = '%sarkivstruktur/part/' % self.relbaseurl
        korrpartrel = '%sarkivstruktur/korrespondansepart/' % self.relbaseurl
        dokflytrel = '%ssakarkiv/dokumentflyt/' % self.relbaseurl
        avskrel = '%ssakarkiv/avskrivning/' % self.relbaseurl
        kryssrefrel = '%sarkivstruktur/kryssreferanse/' % self.relbaseurl
        presedensrel = '%ssakarkiv/presedens/' % self.relbaseurl
        nirel = '%sarkivstruktur/nasjonalidentifikator/' % self.relbaseurl
        sequence = [
            'systemID',
            'opprettetDato',
            'opprettetAv',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
        ]
        if self.xml_extended:
            sequence.extend((
                'endretDato',
                'endretAv',
            ))
        sequence.extend((
            'arkivertDato',
            'arkivertAv',
            'referanseArkivdel',

            (partrel,     self.recurse_xml_part),

            ('kassasjon', self.recurse_xml_kassasjon),
            ('skjerming', self.recurse_xml_skjerming),
            ('gradering', self.recurse_xml_gradering),

            (dokbeskrrel, self.recurse_xml_dokumentbeskrivelse),

            'registreringsID',
            'tittel',
            'offentligTittel',
            'beskrivelse',
            (self.noekkelordrel, self.recurse_xml_noekkelord),
            (self.forfatterrel, self.recurse_xml_forfatter),
            'dokumentmedium.kodenavn>dokumentmedium',
            'dokumentmedium.kode>[null]',
            (self.oppbevrel, self.recurse_xml_oppbevaringssted),
            ('virksomhetsspesifikkeMetadata', self.recurse_xml_virksomhetsspesifikkeMetadata),

            (merknadrel, self.recurse_xml_merknad),
#            (kryssrefrel, self.recurse_xml_kryssreferanse), # FIXME for registrering
            (korrpartrel, self.recurse_xml_korrespondansepart),
            (nirel, self.recurse_xml_national_identifier),
        ))
        if attr and 'journalpost' == attr['xsi:type']:
            sequence.extend((
                'journalaar',
                'journalsekvensnummer',
                'journalpostnummer',
                'journalposttype.kodenavn>journalposttype',
                'journalposttype.kode>[null]',
                'journalstatus.kodenavn>journalstatus',
                'journalstatus.kode>[null]',
                'journaldato',
                'dokumentetsDato',
                'mottattDato',
                'sendtDato',
                'forfallsdato',
                'offentlighetsvurdertDato',
                'antallVedlegg',
                'utlaantDato',
                'utlaantTil',
                'journalenhet',

                (avskrel, self.recurse_xml_avskrivning),
                (dokflytrel, self.recurse_xml_dokumentflyt),
                (presedensrel, self.recurse_xml_presedens),
                ('elektroniskSignatur', self.recurse_xml_elektroniskSignatur),
        ))
        if attr and 'arkivnotat'== attr['xsi:type']:
            sequence.extend((
                'dokumentetsDato',
                'mottattDato',
                'sendtDato',
                'forfallsdato',
                'offentlighetsvurdertDato',
                'antallVedlegg',
                'utlaantDato',
                'utlaantTil',
                (dokflytrel, self.recurse_xml_dokumentflyt),
        ))
        if attr and 'moeteregistrering' == attr['xsi:type']:
            sequence.extend((
                'moeteregistreringstype.kodenavn>moeteregistreringstype',
                'moeteregistreringstype.kode>[null]',
                'moetesakstype.kodenavn>moetesakstype',
                'moetesakstype.kode>[null]',
                'moeteregistreringsstatus.kodenavn>moeteregistreringsstatus',
                'moeteregistreringsstatus.kode>[null]',
                'administrativEnhet',
                'saksbehandler',
#                ('referanseTilMoeteregistrering'), # FIXME for moeteregistrering
#                ('referanseFraMoeteregistrering'), # FIXME for moeteregistrering
        ))
        self.recurse_xml_out_ordered(output, 'registrering', content, sequence, attr=attr)
        self.stats_add('registrering')


    def recurse_xml_mappe(self, output, content):
        entityrel = self.entity_rel(content)
        typemap = {
            '%ssakarkiv/saksmappe/' % self.relbaseurl: 'saksmappe',
        }
        attr = None
        if entityrel in typemap:
            attr = {'xsi:type': typemap[entityrel]}
        merknadrel = '%sarkivstruktur/merknad/' % self.relbaseurl
        partrel = '%sarkivstruktur/part/' % self.relbaseurl
        undermapperel = '%sarkivstruktur/undermappe/' % self.relbaseurl
        registreringrel = '%sarkivstruktur/registrering/' % self.relbaseurl
        kryssrefrel = '%sarkivstruktur/kryssreferanse/' % self.relbaseurl
        presedensrel = '%ssakarkiv/presedens/' % self.relbaseurl
        nirel = '%sarkivstruktur/nasjonalidentifikator/' % self.relbaseurl

        if self.args.onlyclosed:
            filter = '?$filter=avsluttetDato+ne+null'
            rfilter = '?$filter=arkivertDato+ne+null'
        else:
            filter = ""
            rfilter = ""

        sequence = [
            'systemID',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
        ]
        if self.xml_extended:
            sequence.extend((
                'endretDato',
                'endretAv',
            ))
        sequence.extend((
            'mappeID',
            'tittel',
            'offentligTittel',
            'beskrivelse',
            (self.noekkelordrel, self.recurse_xml_noekkelord),
            'dokumentmedium.kodenavn>dokumentmedium',
            'dokumentmedium.kode>[null]',
            (self.oppbevrel, self.recurse_xml_oppbevaringssted),
            'opprettetDato',
            'opprettetAv',
            'avsluttetDato',
            'avsluttetAv',
# mappe.referanseArkivdel er ikke omtalt i tjenestegrensesnittet, kun
# i arkivstruktur.xsd med 0..*.  Derimot finnes det en relasjon til
# arkivdel med 0..1.
#            ('referanseArkivdel'), # FIXME for mappe
            ('virksomhetsspesifikkeMetadata', self.recurse_xml_virksomhetsspesifikkeMetadata),

            (partrel,                  self.recurse_xml_part),
#            (kryssrefrel, self.recurse_xml_kryssreferanse), # FIXME for mappe
            (merknadrel, self.recurse_xml_merknad),
            ('kassasjon', self.recurse_xml_kassasjon),
            ('skjerming', self.recurse_xml_skjerming),
            ('gradering', self.recurse_xml_gradering),

            (undermapperel,            self.recurse_xml_mappe, filter),
            (registreringrel,          self.recurse_xml_registrering, rfilter),
            (nirel, self.recurse_xml_national_identifier),
        ))
        if attr and 'saksmappe' == attr['xsi:type']:
            sequence.extend((
                'saksaar',
                'sakssekvensnummer',
                'saksdato',
                'administrativEnhet',
                'saksansvarlig',
                'journalenhet',
                'saksstatus.kodenavn>saksstatus',
                'saksstatus.kode>[null]',
                'utlaantDato',
                'utlaantTil',
#                ('referanseSekundaerKlassifikasjon'), # FIXME for saksmappe
                (presedensrel, self.recurse_xml_presedens),
        ))
        if attr and 'moetemappe' == attr['xsi:type']:
            sequence.extend((
                'moetenummer',
                'utvalg',
                'moetedato',
                'moetested',
                'referanseForrigeMoete',
                'referanseNesteMoete',
                'moetedeltaker',
        ))
        self.recurse_xml_out_ordered(output, 'mappe', content, sequence, attr=attr)
        self.stats_add('mappe')


    def recurse_xml_klasse(self, output, content):
        underklasserel = '%sarkivstruktur/underklasse/' % self.relbaseurl
        mapperel = '%sarkivstruktur/mappe/' % self.relbaseurl
        registreringrel = '%sarkivstruktur/registrering/' % self.relbaseurl
        kryssrefrel = '%sarkivstruktur/kryssreferanse/' % self.relbaseurl

        if self.args.onlyclosed:
            filter = '?$filter=avsluttetDato+ne+null'
            rfilter = '?$filter=arkivertDato+ne+null'
        else:
            filter = ""
            rfilter = ""

        sequence = [
            'systemID',
            'klasseID',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
        ]
        if self.xml_extended:
            sequence.extend((
                'endretDato',
                'endretAv',
            ))
        sequence.extend((
            'tittel',
            'beskrivelse',
            (self.noekkelordrel, self.recurse_xml_noekkelord),
            'opprettetDato',
            'opprettetAv',
            'avsluttetDato',
            'avsluttetAv',

#            (kryssrefrel, self.recurse_xml_kryssreferanse), # FIXME for klasse
            ('kassasjon', self.recurse_xml_kassasjon),
            ('skjerming', self.recurse_xml_skjerming),
            ('gradering', self.recurse_xml_gradering),

            (underklasserel,  self.recurse_xml_klasse),
            (mapperel,        self.recurse_xml_mappe, filter),
            (registreringrel, self.recurse_xml_registrering, rfilter),
        ))
        self.recurse_xml_out_ordered(output, 'klasse', content, sequence)


    def recurse_xml_klassifikasjonssystem(self, output, content):
        klasserel = '%sarkivstruktur/klasse/' % self.relbaseurl
        sequence = [
            'systemID',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
        ]
        if self.xml_extended:
            sequence.extend((
                'endretDato',
                'endretAv',
            ))
        sequence.extend((
            'klassifikasjonstype.kodenavn>klassifikasjonstype',
            'klassifikasjonstype.kode>[null]',
            'tittel',
            'beskrivelse',
            'opprettetDato',
            'opprettetAv',
            'avsluttetDato',
            'avsluttetAv',
            (klasserel, self.recurse_xml_klasse),
        ))
        self.recurse_xml_out_ordered(output, 'klassifikasjonssystem', content, sequence)


    def recurse_xml_arkivskaper(self, output, content):
        self.recordCreators.append(copy.deepcopy(content))
        sequence = (
            'systemID>[null]',
            'arkivskaperID',
            'arkivskaperNavn',
            'beskrivelse'
        )
        self.recurse_xml_out_ordered(output, 'arkivskaper', content, sequence)


    def recurse_xml_arkivdel(self, output, content):
        klassifikasjonssystemrel = '%sarkivstruktur/klassifikasjonssystem/' % self.relbaseurl
        mapperel = '%sarkivstruktur/mappe/' % self.relbaseurl
        saksmapperel = '%sarkivstruktur/saksmappe/' % self.relbaseurl
        registreringrel = '%sarkivstruktur/arkivskaper/' % self.relbaseurl

        if self.args.onlyclosed:
            filter = '?$filter=avsluttetDato+ne+null'
            rfilter = '?$filter=arkivertDato+ne+null'
        else:
            filter = ""
            rfilter = ""

        sequence = [
            'systemID',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
        ]
        if self.xml_extended:
            sequence.extend((
                'endretDato',
                'endretAv',
            ))
        sequence.extend((
            'tittel',
            'beskrivelse',
            'arkivdelstatus.kodenavn>arkivdelstatus',
            'arkivdelstatus.kode>[null]',
            'dokumentmedium.kodenavn>dokumentmedium',
            'dokumentmedium.kode>[null]',
#            (self.oppbevrel, self.recurse_xml_oppbevaringssted), # FIXME 404 on arkivdel
            'opprettetDato',
            'opprettetAv',
            'avsluttetDato',
            'avsluttetAv',
            'arkivperiodeStartDato',
            'arkivperiodeSluttDato',
            'referanseForloeper',
            'referanseArvtaker',
            ('kassasjon', self.recurse_xml_kassasjon),
            ('utfoertKassasjon', self.recurse_xml_utfoertKassasjon),
            ('sletting', self.recurse_xml_sletting),
            ('skjerming', self.recurse_xml_skjerming),
            ('gradering', self.recurse_xml_gradering),

            (klassifikasjonssystemrel, self.recurse_xml_klassifikasjonssystem),
            (mapperel, self.recurse_xml_mappe, filter),
            (saksmapperel, self.recurse_xml_mappe, filter),
            (registreringrel, self.recurse_xml_registrering, rfilter),
        ))
        self.recurse_xml_out_ordered(output, 'arkivdel', content, sequence)


    def recurse_xml_arkiv(self, output, content, first=False):
        underarkivrel = '%sarkivstruktur/underarkiv/' % self.relbaseurl
        arkivdelrel = '%sarkivstruktur/arkivdel/' % self.relbaseurl
        arkivskaperrel = '%sarkivstruktur/arkivskaper/' % self.relbaseurl

        if self.args.onlyclosed:
            filter = '?$filter=avsluttetDato+ne+null'
        else:
            filter = ""

        # From n5v5 arkivstruktur.xsd:
        sequence = [
            'systemID',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
        ]
        if self.xml_extended:
            sequence.extend((
                'endretDato',
                'endretAv',
            ))
        sequence.extend((
            'tittel',
            'beskrivelse',
            'arkivstatus.kodenavn>arkivstatus',
            'arkivstatus.kode>[null]',
            'dokumentmedium.kodenavn>dokumentmedium',
            'dokumentmedium.kode>[null]',
            (self.oppbevrel, self.recurse_xml_oppbevaringssted),
            'opprettetDato',
            'opprettetAv',
            'avsluttetDato',
            'avsluttetAv',
            (arkivskaperrel, self.recurse_xml_arkivskaper),
            (underarkivrel,  self.recurse_xml_arkiv, filter),
            (arkivdelrel,    self.recurse_xml_arkivdel, filter),
        ))
        attr = None
        if first:
            attr = {
                'xmlns': 'http://www.arkivverket.no/standarder/noark5/arkivstruktur',
                'xmlns:xsd': 'http://www.w3.org/2001/XMLSchema',
                'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance'
            }
            vsmns = []
            schemaLocations = [
                "http://www.arkivverket.no/standarder/noark5/arkivstruktur arkivstruktur.xsd"
            ]
            vsmlist = self.get_vsm_list()
            if 'count' in vsmlist and 0 < vsmlist['count']:
                for t in sorted(vsmlist['results'], key=lambda x: x['navn']):
                    ns, field = t['navn'].split(':', 1)
                    if ns not in vsmns:
                        vsmns.append(ns)
                        vsmurl = '%sschemas/%s.xsd' % (self.baseurl, ns)
                        attr['xmlns:%s' % ns] = vsmurl
                        schemaLocations.append("%s %s.xsd" % (vsmurl, ns))
                if schemaLocations:
                    attr['xsi:schemaLocation'] = " ".join(schemaLocations)

        self.recurse_xml_out_ordered(output, 'arkiv', content, sequence, attr=attr)

    def get_vsm_list(self):
        relurl = "%smetadata/virksomhetsspesifikkeMetadata/" \
            % self.relbaseurl
        url = self.findRelation(relurl)
        print("looking up %s" % url)
        (entry, res) = self.json_get(url)
        #print(entry)
        return json.loads(entry)

    def save_xml_vsm_xsd(self, savepath):
        self._mkdir_recursive(savepath)
        vsmlist = self.get_vsm_list()
        if 'count' in vsmlist and 0 >= vsmlist['count']:
            if hasattr(self, 'seenvsm'):
                # Something is wrong in API, missing information
                # needed to generate XSD file.
                print("error: Missing metadata information for virksomhetsspesifikkeMetadata XSD")
                return
        else:
            namespaces = []
            if hasattr(self, 'seenvsm'):
                seen = self.seenvsm.copy()
            else:
                seen = {}
            for t in sorted(vsmlist['results'], key=lambda x: x['navn']):
                ns, field = t['navn'].split(':', 1)
                if ns not in namespaces:
                    namespaces.append(ns)
                if t['navn'] in seen:
                    del seen[t['navn']]
            if seen:
                print("error: missing virksomhetsspesifikkeMetadata definitions:", seen.keys())
            for ns in namespaces:
                filename = '%s/%s.xsd' % (self.savepath, ns)
                with codecs.open(filename, 'w', encoding='UTF-8') as fh:
                    output = XMLFile(fh)
                    vsmurl = '%sschemas/%s.xsd' % (self.baseurl, ns)
                    with output.tag('xs:schema', attr={
                            'attributeFormDefault': 'unqualified',
                            'elementFormDefault': 'qualified',
                            'xmlns:xs' :'http://www.w3.org/2001/XMLSchema',
                            'xmlns' : vsmurl,
                            f'xmlns:{ns}' : vsmurl,
                            'targetNamespace': vsmurl,
                            'version': '1.0',
                    }):
                        knownelement = {}
                        for t in sorted(vsmlist['results'], key=lambda x: x['navn']):
                            fieldns = t['navn'].split(':', 1)[0]
                            if fieldns == ns:
                                knownelement[t['navn']] = t
                        output.writetag('xs:element', attr={
                            'name': ns,
                            'type': ns,
                        })
                        with output.tag('xs:complexType', attr={ 'name': ns }):
                            with output.tag('xs:sequence'):
                                for navn, t in sorted(knownelement.items()):
                                    (fieldns, fieldname) = navn.split(':', 1)
                                    with output.tag('xs:element', attr={
                                            'name': fieldname,
                                            'type': 'xs:' + t['type'],
                                            'minOccurs': 0,
                                    }):
                                        desc = t.get('beskrivelse', None)
                                        src = t.get('kilde', None)
                                        attr = None
                                        if src:
                                            attr = {'source': src}
                                        if desc:
                                            with output.tag('xs:annotation'):
                                                output.writetag('xs:documentation',
                                                                f'{desc}',
                                                                attr=attr)
                self.schemas[os.path.basename(filename)] = sha256_of_file(filename)


    def install_xsd(self, dir):
        import shutil
        import glob
        xsddir = "schemas"
        for xsdpath in glob.glob("%s/*.xsd" % xsddir):
            shutil.copy(xsdpath, dir)
            self.schemas[os.path.basename(xsdpath)] = sha256_of_file(xsdpath)


    def recurse_xml(self):
        try:
            self.login()
        except n5core.endpoint.LoginFailure:
            pass
        arkivhref = self.findRelation('%sarkivstruktur/arkiv/' % self.relbaseurl)
        if self.args.onlyclosed:
            arkivhref += '?$filter=avsluttetDato+ne+null'
        if not arkivhref:
            print(f"error: Unable to locate relation '{arkivhref}', unable to export")
            return -1
        (c, res) = self.json_get(arkivhref)
        arkivinfo = json.loads(c)

        systemhref = self.findRelation('%sadmin/system/' % self.relbaseurl)
        (c, res) = self.json_get(systemhref)
        self.system = json.loads(c)

        utcnow = datetime.datetime.utcnow().replace(microsecond=0, tzinfo=pytz.utc).isoformat()
        if 'count' not in arkivinfo or 0 < arkivinfo['count']:
            for arkiv in arkivinfo['results']:
                arkivcopy = copy.deepcopy(arkiv)
                # Blank stats per extract
                self.stats = {}
                self.files = {}
                self.schemas = {}
                self.recordCreators = []
                if hasattr(self, 'seenvsm'):
                    del self.seenvsm
                self.savepath = 'uttrekk-%s/arkiv-%s-%s' % (
                    utcnow,
                    arkiv['systemID'],
                    arkiv['tittel'].replace('/', '_'))
                self._mkdir_recursive(self.savepath)
                self.install_xsd(self.savepath)
                filename = '%s/arkivstruktur.xml' % self.savepath
                with codecs.open(filename, 'w',
                                 encoding='UTF-8') as fh:
                    output = XMLFile(fh)
                    self.recurse_xml_arkiv(output, arkiv, first=True)
                    self.files['arkivstruktur.xml'] = sha256_of_file(filename)
                self.save_xml_vsm_xsd(self.savepath)
                self.recurse_xml_save_arkivuttrekk(arkivcopy)


    def recurse_xml_save_arkivuttrekk(self, arkiv):
        with codecs.open('%s/arkivuttrekk.xml' % self.savepath, 'w',
                         encoding='UTF-8') as fh:
            output = XMLFile(fh)
            attr = {
                'xmlns': 'http://www.arkivverket.no/standarder/addml',
                'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
                'name': arkiv['tittel'],

            }
            def element(output, name, value):
                with output.tag('additionalElement', attr={'name': name}):
                     output.writetag('value', value)
            def property(output, name, value, dataType=None):
                attr={'name': name}
                if dataType:
                    attr['dataType'] = dataType
                with output.tag('property', attr=attr):
                    output.writetag('value', value)
            def xmlfile(output, filetype, filename, filesha256):
                with output.tag('property', attr={'name': filetype}):
                    property(output, 'name', filename)
                    with output.tag('property', attr={'name': 'format'}):
                        with output.tag('properties'):
                            output.writetag('property', '1.0', attr={'name': 'version'})
                    with output.tag('property', attr={'name': 'format'}):
                        output.writetag('value', 'XML')
                        with output.tag('properties'):
                            property(output, 'algorithm', 'SHA-256')
                            property(output, 'value', filesha256)
            with output.tag('addml', attr=attr):
                with output.tag('dataset'):
                    description = 'dummy arkiv.beskrivelse blank'
                    if 'beskrivelse' in arkiv:
                        description = arkiv['beskrivelse']
                    output.writetag('description', description)
                    with output.tag('reference'):
                        with output.tag('context'):
                            with output.tag('additionalElements'):
                                for recordCreator in self.recordCreators:
                                    element(output, 'recordCreators', recordCreator['arkivskaperNavn'])
                                element(output, 'systemType', 'dummy system type')
                                element(output, 'systemName',
                                        f"{self.system['leverandoer']} {self.system['produkt']} {self.system['versjon']}")
                                element(output, 'archive', arkiv['tittel'])
                        with output.tag('context'):
                            with output.tag('additionalElements'):
                                with output.tag('additionalElement',
                                                attr={'name': 'archivalPeriod'}):
                                    with output.tag('properties'):
                                        property(output, 'startDate', arkiv['opprettetDato'])
                                        endDate = utcnowtz()\
                                            .replace(microsecond=0) \
                                            .isoformat() \
                                            .replace('+00:00', 'Z')
                                        if 'avsluttetDato' in arkiv:
                                            endDate = arkiv['avsluttetDato']
                                        property(output, 'endDate', endDate)
                    with output.tag('dataObjects'):
                        with output.tag('dataObject',
                                        attr={'name': 'dummy object name'}):
                            with output.tag('properties'):
                                with output.tag('property',
                                                attr={'name': 'info'}):
                                    with output.tag('properties'):
                                        with output.tag('property',
                                                        attr={'name': 'type'}):
                                            output.tag('value', 'dummy type')
                                            with output.tag('properties'):
                                                property(output, 'version', 'dummy version')
                                        with output.tag('property',
                                                        attr={'name': 'additionalInfo'}):
                                            with output.tag('properties'):
                                                with output.tag('property',
                                                                attr={'name': 'periode'}):
                                                    with output.tag('properties'):
                                                        property(output, 'inngaaendeSkille', 'mykt dummy')
                                                        property(output, 'utgaaendeSkille', 'mykt dummy')
                                                property(output,
                                                         'inneholderSkjermetInformasjon',
                                                         output.bool2str(0 < self.stats_get('skjerming')))
                                                property(output,
                                                         'omfatterDokumenterSomErKassert',
                                                         output.bool2str(0 < self.stats_get('utfoertKassasjon')))
                                                property(output,
                                                         'inneholderDokumenterSomSkalKasseres',
                                                         output.bool2str(0 < self.stats_get('kassasjon')))
                                                property(output,
                                                         'inneholderVirksomhetsspesifikkeMetadata',
                                                         output.bool2str(hasattr(self, 'seenvsm')))
                                                property(output, 'antallDokumentfiler', str(self.stats_get('referanseDokumentfil')))
                            with output.tag('dataObjects'):
                                with output.tag('dataObject', attr={'name': 'arkivstruktur'}):
                                    with output.tag('properties'):
                                        for filename in self.files.keys():
                                            xmlfile(output, 'file', filename, self.files[filename])
                                        for schema in self.schemas.keys():
                                            xmlfile(output, 'schema', schema, self.schemas[schema])
                                        with output.tag('property', attr={'name':'numberOfOccurrences'}):
                                            output.writetag('value', 'mappe')
                                            with output.tag('properties'):
                                                property(output, 'elementPath', '//mappe')
                                                property(output, 'value', str(self.stats_get('mappe')), dataType='integer')
                                        with output.tag('property', attr={'name':'numberOfOccurrences'}):
                                            output.writetag('value', 'registrering')
                                            with output.tag('properties'):
                                                property(output, 'elementPath', '//registrering')
                                                property(output, 'value', str(self.stats_get('registrering')), dataType='integer')


    def recurse(self):
        try:
            self.login()
        except n5core.endpoint.LoginFailure:
            pass
        print('Saving to %s' % self.savedir)
        urlsleft = ['.']
        urlseen = {}
        urlsrc = {'.': 'root'}
        while 0 < len(urlsleft):
            url = urlsleft.pop(0)
            if url in urlseen:
                continue
            urlseen[url] = 1

            purl = urlparse(url)
            pathurl = purl._replace(query=urllib
                                    .parse.quote_plus(purl.query)).geturl()
            path = pathurl.replace(self.baseurl, '')
            path = path.rstrip('/').replace('/.', '/index')
            path = path + '.json'
            path = os.path.join(self.savedir, path)
            if -1 != path.find('//') or '/' == path[0]:
                print('error: bogus url %s seen in %s (path %s)' % ( url, urlsrc[url], path))
                continue

            try:
                if self.verbose:
                    print('info: Fetching %s' % url)
                else:
                    sys.stdout.write('.')
                    sys.stdout.flush()
                (content, res) = self._get(url)

                ctype = res.getheader('Content-Type')

                if self.verbose:
                    print('info: Creating %s for %s' % (path, url))
                dir = os.path.dirname(path)
                self._mkdir_recursive(dir)
                if ctype and 0 == ctype.find('application/vnd.noark5+json'):
                    f = open(path, 'w')
                    j = json.loads(content.decode("UTF-8"))
                    f.write(json.dumps(j, indent=2))
                else:
                    f = open(path, 'wb')
                    f.write(content)
                f.close()

                if ctype is None:
                    print('error: No Content-Type from %s' % url)
                if ctype is None \
                   or (0 != ctype.find('application/vnd.noark5+json') \
                       and 0 != ctype.find('application/json')):
                    print('info: ignoring %s' % url)
                else:
                    try:
                        baseref = j
                    except ValueError as e:
                        print('error: non-JSON content returned for %s' % url)
                        baseref = None
                    if baseref is None:
                        print('error: JSON MIME type but no JSON in %s' % url)
                    elif type(baseref) is list:
                        print('error: found json list in %s' % url)
                    elif '_links' in baseref:
                        for rel in baseref['_links'].keys():
                            if 'href' in baseref['_links'][rel]:
                                href = baseref['_links'][rel]['href']
                                if 'templated' in baseref['_links'][rel] and baseref['_links'][rel]['templated']:
                                    href = href.split('{')[0]
                                if href not in urlseen:
                                    urlsleft.append(href)
                                    if href not in urlsrc:
                                        urlsrc[href] = []
                                    urlsrc[href].append(url)
                    if baseref is not None and type(baseref) is not list:
                        for basekey in baseref.keys():
                            if basekey != '_links' and type(baseref[basekey]) is list:
                                for element in baseref[basekey]:
                                    if '_links' in element and len(element['_links'].keys()) > 0:
                                        for rel in element['_links'].keys():
                                            href = element['_links'][rel]['href']
                                            if href not in urlseen:
                                                urlsleft.append(href)
                                                if href not in urlsrc:
                                                    urlsrc[href] = []
                                                urlsrc[href].append(url)
            except HTTPError as e:
                pass
        if not self.verbose:
            print('')

def main():
    t = ContentDumper()
    if t.xml:
        return t.recurse_xml()
    else:
        return t.recurse()

if __name__ == '__main__':
    exit(main())
