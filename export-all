#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import print_function

import sys
import os
sys.path.append(os.path.join(sys.path[0],'lib'))

import argparse
import datetime
import json
import pytz
import n5core.endpoint
import six
from n5core.endpoint import HTTPError
import codecs
from xml.sax.saxutils import escape

class XMLTag(object):
    def __init__(self, level, fh, tagname, attr=None):
        self.fh = fh
        self.tagname = tagname
        self.attr = attr
        self.level = level


    def __enter__(self):
        if self.attr:
            self.fh.write('%s<%s %s>\n' % ('  ' * self.level[0], self.tagname, self.attr))
        else:
            self.fh.write('%s<%s>\n' % ('  ' * self.level[0], self.tagname))
        self.level[0] +=1


    def __exit__(self, tpe, value, traceback):
        self.level[0] -=1
        self.fh.write('%s</%s>\n' % ('  ' * self.level[0], self.tagname))


class XMLFile(object):
    def __init__(self, fh):
        self.level = [0] # Using ref to allow XMLTag to update the value
        self.fh = fh
        fh.write('<?xml version="1.0" encoding="UTF-8"?>\n')


    def tag(self, name, attr=None):
        return XMLTag(self.level, self.fh, name, attr=attr)


    def write(self, s):
        return self.fh.write(s)


    def writetag(self, tagname, s):
        if isinstance(s, six.text_type):
            s = escape(s)
        self.fh.write('%s<%s>%s</%s>\n' % ('  ' * self.level[0], tagname, s, tagname))


class ContentDumper(n5core.endpoint.Endpoint):
    def __init__(self):
        self.baseurl = 'http://localhost:8092/noark5v4/'
        utcnow = datetime.datetime.utcnow().replace(microsecond=0, tzinfo=pytz.utc)
        self.savedir = 'json-dump-%s' % utcnow.isoformat()
        parser = argparse.ArgumentParser()
        parser.add_argument('--baseurl', help='(default is %s)' % self.baseurl)
        parser.add_argument('--xml', help='(default is false)',
                            default=False, action='store_true')
        parser.add_argument('--savedir', help='(default is %s)' % self.savedir)
        parser.add_argument('--verbose', help='enable debug output',
                            action='store_true')
        parser.add_argument('--xml-extended', help='enable extended (aka non-official) XML output',
                            action='store_true')
        args = parser.parse_args()
        if args.baseurl:
            self.baseurl = args.baseurl
        if args.savedir:
            self.savedir = args.savedir
        n5core.endpoint.Endpoint.__init__(self,self.baseurl)
        self.verbose = args.verbose
        self.xml = args.xml
        self.xml_extended = args.xml_extended

    def _mkdir_recursive(self, path):
        sub_path = os.path.dirname(path)
        if '' != sub_path and not os.path.exists(sub_path):
            self._mkdir_recursive(sub_path)
        if not os.path.exists(path):
            os.mkdir(path)



    def recurse_xml_out_ordered(self, output, entity, content, sequence, attr=None):
        with output.tag(entity, attr=attr):
#            if self.verbose:
#                print(content)
            for k in sequence:
                keytype = type(k)
                if str == keytype:
                    if -1 != k.find('>'):
                        f, t = k.split('>')
                        if -1 != f.find('.'):
                            a, b = f.split('.')
                            if a in content and b in content[a]:
                                if '[null]' != t:
                                    output.writetag(t, content[a][b])
                                del content[a][b]
                                if not content[a].keys():
                                    del content[a]
                        else:
                            if f in content:
                                if '[null]' != t:
                                    output.writetag(t, content[f])
                                del content[f]
                    else:
                        if k in content:
                            output.writetag(k, content[k])
                            del content[k]
                elif tuple == keytype:
                    rel = k[0]
                    if rel in content['_links']:
                        url = content['_links'][rel]['href']
                        (c, res) = self.json_get(url)
                        info = json.loads(c)
                        # Process list if relation gave non-empty result
                        if ('count' in info and 0 < info['count']) \
                           or 'results' in info:
                            for sub in info['results']:
                                k[1](output, sub)
                        elif not 'count' in info:
                            print('warning: GET %s did not return list' % (url))
                            k[1](output, info)
                    elif rel in content:
                        k[1](output, content[rel])
                        del content[rel]
            if '_links' in content:
                del content['_links']
            if content.keys():
                print('warning: %s XML attribute not exported: %s' % (entity, content))


    def recurse_xml_konvertering(self, output, content):
        sequence = (
            'systemID>[null]',
            'konvertertDato',
            'konvertertAv',
            'konvertertFraFormat.kodenavn>[null]',
            'konvertertFraFormat.kode>konvertertFraFormat',
            'konvertertTilFormat.kodenavn>[null]',
            'konvertertTilFormat.kode>konvertertTilFormat',
            'konverteringsverktoey',
            'konverteringskommentar'
        )
        self.recurse_xml_out_ordered(output, 'konvertering', content, sequence)


    def recurse_xml_merknad(self, output, content):
        sequence = (
            'systemID>[null]',
            'merknadstekst',
            'merknadstype.kodenavn>merknadstype',
            'merknadstype.kode>[null]',
            'merknadsdato',
            'merknadRegistrertAv'
        )
        self.recurse_xml_out_ordered(output, 'merknad', content, sequence)


    def recurse_xml_forfatter(self, output, content):
        output.writetag('forfatter', content['forfatter'])


    def recurse_xml_kassasjon(self, output, content):
        sequence = (
            'kassasjonsvedtak.kodenavn>kassasjonsvedtak',
            'kassasjonsvedtak.kode>[null]',
            'kassasjonshjemmel',
            'bevaringstid',
            'kassasjonsdato',
        )
        self.recurse_xml_out_ordered(output, 'kassasjon', content, sequence)


    def recurse_xml_utfoertKassasjon(self, output, content):
        sequence = (
            'kassertDato',
            'kassertAv',
        )
        self.recurse_xml_out_ordered(output, 'utfoertKassasjon', content, sequence)


    def recurse_xml_sletting(self, output, content):
        sequence = (
            'slettingstype.kodenavn>slettingstype',
            'slettingstype.kode>[null]',
            'slettetDato',
            'slettetAv',
            #'referanseSlettetAv',
        )
        self.recurse_xml_out_ordered(output, 'sletting', content, sequence)


    def recurse_xml_skjerming(self, output, content):
        sequence = (
            'tilgangsrestriksjon.kodenavn>tilgangsrestriksjon',
            'tilgangsrestriksjon.kode>[null]',
            'skjermingshjemmel',
            'skjermingMetadata.kodenavn>skjermingMetadata',
            'skjermingMetadata.kode>[null]',
            'skjermingDokument.kodenavn>skjermingDokument',
            'skjermingDokument.kode>[null]',
            'skjermingsvarighet',
            'skjermingOpphoererDato',
        )
        self.recurse_xml_out_ordered(output, 'skjerming', content, sequence)


    def recurse_xml_gradering(self, output, content):
        sequence = (
            'graderingskode.kodenavn>grad',
            'graderingskode.kode>[null]',
            'graderingsdato',
            'gradertAv',
            'nedgraderingsdato',
            'nedgradertAv',
        )
        self.recurse_xml_out_ordered(output, 'gradering', content, sequence)


    def recurse_xml_elektroniskSignatur(self, output, content):
        sequence = (
            'elektroniskSignaturSikkerhetsnivaa.kodenavn>elektroniskSignaturSikkerhetsnivaa',
            'elektroniskSignaturSikkerhetsnivaa.kode>[null]',
            'elektroniskSignaturVerifisert.kodenavn>elektroniskSignaturVerifisert',
            'elektroniskSignaturVerifisert.kode>[null]',
            'verifisertDato',
            'verifisertAv',
        )
        self.recurse_xml_out_ordered(output, 'elektroniskSignatur', content, sequence)


    def recurse_xml_dokumentobjekt(self, output, content):
        # Not using recurse_xml_out_ordered to handle referanseDokumentfil
        filrel = '%sarkivstruktur/fil/' % self.relbaseurl
        konvrel = '%sarkivstruktur/konvertering/' % self.relbaseurl
        sequence = [
            'systemID',
            'versjonsnummer',
            'variantformat.kodenavn>variantformat',
            'variantformat.kode>[null]',
            'format.kodenavn>[null]',
            'format.kode>format',
            'formatDetaljer',
            'opprettetDato',
            'opprettetAv',
            'referanseDokumentfil',
            'sjekksum',
            'sjekksumAlgoritme',
            'filstoerrelse',
        ]
        if self.xml_extended:
            sequence.extend((
                'filnavn',
                'mimeType',
            ))
        sequence.extend((
            ('elektroniskSignatur', self.recurse_xml_elektroniskSignatur),
            (konvrel, self.recurse_xml_konvertering),
        ))
        with output.tag('dokumentobjekt'):
            for k in sequence:
                if 'referanseDokumentfil' == k:
                    if filrel in content['_links']:
                        self._mkdir_recursive('%s/DOKUMENT' % self.savepath)
                        # Deriving filename from checksum provide
                        # automatic deduplication, assuming there is
                        # no hash collition in the dataset.
                        filename = '%s-%s' % (content['sjekksumAlgoritme'], content['sjekksum'])
                        url = content['_links'][filrel]['href']
                        try:
                            (data, r) = self._get(url)
                            with open('%s/DOKUMENT/%s' % (
                                    self.savepath, filename), 'w') as fh:
                                fh.write(data)
                            output.writetag('referanseDokumentfil',
                                            'DOKUMENT/%s' % filename)
                        except HTTPError as e:
                            print("error: unable to download %s: %s (%s)" % (
                                url, str(e), e.read()))
                            raise
                    continue
                keytype = type(k)
                if str == keytype:
                    if k in content:
                        output.writetag(k, content[k])
                elif tuple == keytype:
                    rel = k[0]
                    if rel in content['_links']:
                        (c, res) = self.json_get(content['_links'][rel]['href'])
                        info = json.loads(c)
                        # Process list if relation gave non-empty result
                        if ('count' in info and 0 < info['count']) \
                           or 'results' in info:
                            # Upgrade to python 3.7. Getting warning:
                            # 'str' object is not callable for k[1](output, sub)
                            for sub in info['results']:
                                k[1](output, sub)


    def recurse_xml_dokumentbeskrivelse(self, output, content):
        partrel = '%sarkivstruktur/part/' % self.relbaseurl
        merknadrel = '%sarkivstruktur/merknad/' % self.relbaseurl
        forfatterrel = '%sforfatter/' % self.nikitarelbaseurl
        dokobjrel = '%sarkivstruktur/dokumentobjekt/' % self.relbaseurl
        sequence = (
            'systemID',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
            'dokumenttype.kodenavn>dokumenttype',
            'dokumenttype.kode>[null]',
            'dokumentstatus.kodenavn>dokumentstatus',
            'dokumentstatus.kode>[null]',
            'tittel',
            'beskrivelse',
            (forfatterrel, self.recurse_xml_forfatter),
            'opprettetDato',
            'opprettetAv',
            'dokumentmedium.kodenavn>dokumentmedium',
            'dokumentmedium.kode>[null]',
            'oppbevaringssted',
#            ('referanseArkivdel'), # FIXME for dokumentbeskrivelse
            'tilknyttetRegistreringSom.kodenavn>tilknyttetRegistreringSom',
            'tilknyttetRegistreringSom.kode>[null]',
            'dokumentnummer',
            'tilknyttetDato',
            'tilknyttetAv',
            (partrel, self.recurse_xml_part),
            (merknadrel, self.recurse_xml_merknad),
            ('kassasjon', self.recurse_xml_kassasjon),
            ('utfoertKassasjon', self.recurse_xml_utfoertKassasjon),
            ('sletting', self.recurse_xml_sletting),
            ('skjerming', self.recurse_xml_skjerming),
            ('gradering', self.recurse_xml_gradering),
            ('elektroniskSignatur', self.recurse_xml_elektroniskSignatur),
            (dokobjrel, self.recurse_xml_dokumentobjekt),
        )
        self.recurse_xml_out_ordered(output, 'dokumentbeskrivelse', content, sequence)

    def recurse_xml_national_identifier(self, output, content):
        if not self.xml_extended:
            return
        sequence = (
            'systemID>[null]',
            'organisasjonsnummer>organisasjonsnummer',
            'foedselsnummer>foedselsnummer',
            'dNummer>dNummer',

            'koordinatsystem.kode>koordinatsystem',
            'x>x',
            'y>y',
            'z>z',

            'kommunenummer>kommunenummer',
            'fylkesnummernummer>fylkesnummernummer',
            'landkode.kode>[null]',
            'landkode.kodenavn>land',
            'planidentifikasjon>planidentifikasjon',

            'bygningsnummer>bygningsnummer',
            'endringsloepenummer>endringsloepenummer',

            'gaardsnummer>gaardsnummer',
            'bruksnummer>bruksnummer',
            'festenummer>festenummer',
            'seksjonsnummer>seksjonsnummer',
        )
        self.recurse_xml_out_ordered(output, 'nasjonalidentifikator', content, sequence)

    def recurse_xml_korrespondansepart(self, output, content):
        sequence = (
            'systemID>[null]',
            'korrespondanseparttype.kodenavn>korrespondanseparttype',
            'korrespondanseparttype.kode>[null]',
            'navn>korrespondansepartNavn',
            'postadresse.addresselinje1>postadresse',
            'postadresse.addresselinje2>postadresse',
            'postadresse.addresselinje3>postadresse',
            'postadresse.postnr>postnummer',
            'postadresse.poststed>poststed',
            'postadresse.landkode>land',
            'kontaktinformasjon.epostadresse>epostadresse',
            'kontaktinformasjon.mobiltelefon>telefonnummer',
            'kontaktinformasjon.telefon>telefonnummer',
            'kontaktperson',
            'administrativEnhet',
            'saksbehandler',
            'virksomhetsspesifikkeMetadata',
        )
        self.recurse_xml_out_ordered(output, 'korrespondansepart', content, sequence)


    def recurse_xml_part(self, output, content):
        sequence = (
            'systemID>partID',
            'partRolle.kodenavn>partRolle',
            'partRolle.kode>[null]',
            'navn>partNavn',
            'postadresse.addresselinje1>postadresse',
            'postadresse.addresselinje2>postadresse',
            'postadresse.addresselinje3>postadresse',
            'postadresse.postnr>postnummer',
            'postadresse.poststed>poststed',
            'postadresse.landkode>land',
            'kontaktinformasjon.epostadresse>epostadresse',
            'kontaktinformasjon.mobiltelefon>telefonnummer',
            'kontaktinformasjon.telefon>telefonnummer',
            'kontaktperson',
            'administrativEnhet',
            'saksbehandler',
            'virksomhetsspesifikkeMetadata',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
        )
        self.recurse_xml_out_ordered(output, 'part', content, sequence)


    def recurse_xml_dokumentflyt(self, output, content):
        sequence = (
            'flytTil',
            'flytFra',
            'flytMottattDato',
            'flytSendtDato',
            'flytStatus.kodenavn>flytStatus',
            'flytStatus.kode>[null]',
            'flytMerknad',
        )
        self.recurse_xml_out_ordered(output, 'dokumentflyt', content, sequence)


    def recurse_xml_avskrivning(self, output, content):
        """
Not yet working because of
https://gitlab.com/OsloMet-ABI/nikita-noark5-core/issues/159
"""
        sequence = [
            'avskrivningsdato',
            'avskrevetAv',
            'avskrivningsmaate.kodenavn>avskrivningsmaate',
            'avskrivningsmaate.kode>[null]',
            'referanseAvskrivesAvJournalpost',
        ]
        if self.xml_extended:
            sequence.extend((
                'referanseAvskrivesAvKorrespondansepart',
            ))
        self.recurse_xml_out_ordered(output, 'avskrivning', content, sequence)


    def recurse_xml_oppbevaringssted(self, output, content):
        output.writetag('oppbevaringssted', content['oppbevaringssted'])


    def recurse_xml_kryssreferanse(self, output, content):
        print('error: "kryssreferanse" not yet implemented')


    def recurse_xml_presedens(self, output, content):
        sequence = (
            'systemID>[null]',
            'presedensDato',
            'opprettetDato',
            'opprettetAv',
            'referanseOpprettetAv>[null]',
            'tittel',
            'beskrivelse',
            'presedensHjemmel',
            'rettskildefaktor',
            'presedensGodkjentDato',
            'presedensGodkjentAv',
            'referansePresedensGodkjentAv>[null]',
            'avsluttetDato',
            'avsluttetAv',
            'referanseAvsluttetAv>[null]',
            'presedensStatus.kode>[null]',
            'presedensStatus.kodenavn>presedensStatus',
        )
        self.recurse_xml_out_ordered(output, 'presedens', content, sequence)

    def recurse_xml_registrering(self, output, content):
        entityrel = self.entity_rel(content)
        typemap = {
            '%ssakarkiv/journalpost/' % self.relbaseurl: 'journalpost',
            '%ssakarkiv/arkivnotat/' % self.relbaseurl: 'arkivnotat',
        }
        attr = None
        if entityrel in typemap:
            attr = 'xsi:type="%s"' % typemap[entityrel]
        merknadrel = '%sarkivstruktur/merknad/' % self.relbaseurl
        forfatterrel = '%sforfatter/' % self.nikitarelbaseurl
        dokbeskrrel = '%sarkivstruktur/dokumentbeskrivelse/' % self.relbaseurl
        partrel = '%sarkivstruktur/part/' % self.relbaseurl
        korrpartrel = '%sarkivstruktur/korrespondansepart/' % self.relbaseurl
        dokflytrel = '%ssakarkiv/dokumentflyt/' % self.relbaseurl
        avskrel = '%ssakarkiv/avskrivning/' % self.relbaseurl
        oppbevrel = '%soppbevaringssted/' % self.nikitarelbaseurl
        kryssrefrel = '%sarkivstruktur/kryssreferanse/' % self.relbaseurl
        presedensrel = '%ssakarkiv/presedens/' % self.relbaseurl
        nirel = '%sarkivstruktur/nasjonalidentifikator/' % self.relbaseurl
        sequence = (
            'systemID',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
            'opprettetDato',
            'opprettetAv',
            'arkivertDato',
            'arkivertAv',
            'referanseArkivdel',

            (partrel,     self.recurse_xml_part),

            ('kassasjon', self.recurse_xml_kassasjon),
            ('skjerming', self.recurse_xml_skjerming),
            ('gradering', self.recurse_xml_gradering),

            (dokbeskrrel, self.recurse_xml_dokumentbeskrivelse),

            'registreringsID',
            'tittel',
            'offentligTittel',
            'beskrivelse',
            'noekkelord',
            (forfatterrel, self.recurse_xml_forfatter),
            'dokumentmedium.kodenavn>dokumentmedium',
            'dokumentmedium.kode>[null]',
            (oppbevrel, self.recurse_xml_oppbevaringssted), # FIXME for registrering
            'virksomhetsspesifikkeMetadata',

            (merknadrel, self.recurse_xml_merknad),
#            (kryssrefrel, self.recurse_xml_kryssreferanse), # FIXME for registrering
            (korrpartrel, self.recurse_xml_korrespondansepart),
            (nirel, self.recurse_xml_national_identifier),
        )
        if 'xsi:type="journalpost"' == attr:
            sequence = sequence + (
                'journalaar',
                'journalsekvensnummer',
                'journalpostnummer',
                'journalposttype.kodenavn>journalposttype',
                'journalposttype.kode>[null]',
                'journalstatus.kodenavn>journalstatus',
                'journalstatus.kode>[null]',
                'journaldato',
                'dokumentetsDato',
                'mottattDato',
                'sendtDato',
                'forfallsdato',
                'offentlighetsvurdertDato',
                'antallVedlegg',
                'utlaantDato',
                'utlaantTil',
                'journalenhet',

                (avskrel, self.recurse_xml_avskrivning),
                (dokflytrel, self.recurse_xml_dokumentflyt),
                (presedensrel, self.recurse_xml_presedens),
                ('elektroniskSignatur', self.recurse_xml_elektroniskSignatur),
            )
        if 'xsi:type="arkivnotat"' == attr:
            sequence = sequence + (
                'dokumentetsDato',
                'mottattDato',
                'sendtDato',
                'forfallsdato',
                'offentlighetsvurdertDato',
                'antallVedlegg',
                'utlaantDato',
                'utlaantTil',
                (dokflytrel, self.recurse_xml_dokumentflyt),
            )
        if 'xsi:type="moeteregistrering"' == attr:
            sequence = sequence + (
                'moeteregistreringstype.kodenavn>moeteregistreringstype',
                'moeteregistreringstype.kode>[null]',
                'moetesakstype.kodenavn>moetesakstype',
                'moetesakstype.kode>[null]',
                'moeteregistreringsstatus.kodenavn>moeteregistreringsstatus',
                'moeteregistreringsstatus.kode>[null]',
                'administrativEnhet',
                'saksbehandler',
#                ('referanseTilMoeteregistrering'), # FIXME for moeteregistrering
#                ('referanseFraMoeteregistrering'), # FIXME for moeteregistrering
            )
        self.recurse_xml_out_ordered(output, 'registrering', content, sequence, attr=attr)


    def recurse_xml_mappe(self, output, content):
        entityrel = self.entity_rel(content)
        typemap = {
            '%ssakarkiv/saksmappe/' % self.relbaseurl: 'saksmappe',
        }
        attr = None
        if entityrel in typemap:
            attr = 'xsi:type="%s"' % typemap[entityrel]
        merknadrel = '%sarkivstruktur/merknad/' % self.relbaseurl
        partrel = '%sarkivstruktur/part/' % self.relbaseurl
        undermapperel = '%sarkivstruktur/undermappe/' % self.relbaseurl
        registreringrel = '%sarkivstruktur/registrering/' % self.relbaseurl
        oppbevrel = '%soppbevaringssted/' % self.nikitarelbaseurl
        kryssrefrel = '%sarkivstruktur/kryssreferanse/' % self.relbaseurl
        presedensrel = '%ssakarkiv/presedens/' % self.relbaseurl
        nirel = '%sarkivstruktur/nasjonalidentifikator/' % self.relbaseurl
        sequence = (
            'systemID',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
            'mappeID',
            'tittel',
            'offentligTittel',
            'beskrivelse',
#            ('noekkelord'), # FIXME for mappe
            'dokumentmedium.kodenavn>dokumentmedium',
            'dokumentmedium.kode>[null]',
            (oppbevrel, self.recurse_xml_oppbevaringssted), # FIXME for mappe
            'opprettetDato',
            'opprettetAv',
            'avsluttetDato',
            'avsluttetAv',
# mappe.referanseArkivdel er ikke omtalt i tjenestegrensesnittet, kun
# i arkivstruktur.xsd med 0..*.  Derimot finnes det en relasjon til
# arkivdel med 0..1.
#            ('referanseArkivdel'), # FIXME for mappe
            'virksomhetsspesifikkeMetadata',

            (partrel,                  self.recurse_xml_part),
#            (kryssrefrel, self.recurse_xml_kryssreferanse), # FIXME for mappe
            (merknadrel, self.recurse_xml_merknad),
            ('kassasjon', self.recurse_xml_kassasjon),
            ('skjerming', self.recurse_xml_skjerming),
            ('gradering', self.recurse_xml_gradering),

            (undermapperel,            self.recurse_xml_mappe),
            (registreringrel,          self.recurse_xml_registrering),
            (nirel, self.recurse_xml_national_identifier),
        )
        if 'xsi:type="saksmappe"' == attr:
            sequence = sequence + (
                'saksaar',
                'sakssekvensnummer',
                'saksdato',
                'administrativEnhet',
                'saksansvarlig',
                'journalenhet',
                'saksstatus.kodenavn>saksstatus',
                'saksstatus.kode>[null]',
                'utlaantDato',
                'utlaantTil',
#                ('referanseSekundaerKlassifikasjon'), # FIXME for saksmappe
                (presedensrel, self.recurse_xml_presedens),
            )
        if 'xsi:type="moetemappe"' == attr:
            sequence = sequence + (
                'moetenummer',
                'utvalg',
                'moetedato',
                'moetested',
                'referanseForrigeMoete',
                'referanseNesteMoete',
                'moetedeltaker',
            )
        self.recurse_xml_out_ordered(output, 'mappe', content, sequence, attr=attr)


    def recurse_xml_klasse(self, output, content):
        underklasserel = '%sarkivstruktur/underklasse/' % self.relbaseurl
        mapperel = '%sarkivstruktur/mappe/' % self.relbaseurl
        registreringrel = '%sarkivstruktur/registrering/' % self.relbaseurl
        kryssrefrel = '%sarkivstruktur/kryssreferanse/' % self.relbaseurl
        sequence = (
            'systemID',
            'klasseID',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
            'tittel',
            'beskrivelse',
#            ('noekkelord'), # FIXME for klasse
            'opprettetDato',
            'opprettetAv',
            'avsluttetDato',
            'avsluttetAv',

#            (kryssrefrel, self.recurse_xml_kryssreferanse), # FIXME for klasse
            ('kassasjon', self.recurse_xml_kassasjon),
            ('skjerming', self.recurse_xml_skjerming),
            ('gradering', self.recurse_xml_gradering),

            (underklasserel,  self.recurse_xml_klasse),
            (mapperel,        self.recurse_xml_mappe),
            (registreringrel, self.recurse_xml_registrering),
        )
        self.recurse_xml_out_ordered(output, 'klasse', content, sequence)


    def recurse_xml_klassifikasjonssystem(self, output, content):
        klasserel = '%sarkivstruktur/klasse/' % self.relbaseurl
        sequence = (
            'systemID',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
            'klassifikasjonstype.kodenavn>klassifikasjonstype',
            'klassifikasjonstype.kode>[null]',
            'tittel',
            'beskrivelse',
            'opprettetDato',
            'opprettetAv',
            'avsluttetDato',
            'avsluttetAv',
            (klasserel, self.recurse_xml_klasse),
            )
        self.recurse_xml_out_ordered(output, 'klassifikasjonssystem', content, sequence)


    def recurse_xml_arkivskaper(self, output, content):
        sequence = (
            'systemID>[null]',
            'arkivskaperID',
            'arkivskaperNavn',
            'beskrivelse'
        )
        self.recurse_xml_out_ordered(output, 'arkivskaper', content, sequence)


    def recurse_xml_arkivdel(self, output, content):
        klassifikasjonssystemrel = '%sarkivstruktur/klassifikasjonssystem/' % self.relbaseurl
        mapperel = '%sarkivstruktur/mappe/' % self.relbaseurl
        saksmapperel = '%sarkivstruktur/saksmappe/' % self.relbaseurl
        registreringrel = '%sarkivstruktur/arkivskaper/' % self.relbaseurl
        oppbevrel = '%soppbevaringssted/' % self.nikitarelbaseurl
        sequence = (
            'systemID',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
            'tittel',
            'beskrivelse',
            'arkivdelstatus.kodenavn>arkivdelstatus',
            'arkivdelstatus.kode>[null]',
            'dokumentmedium.kodenavn>dokumentmedium',
            'dokumentmedium.kode>[null]',
#            (oppbevrel, self.recurse_xml_oppbevaringssted), # FIXME for arkivdel
            'opprettetDato',
            'opprettetAv',
            'avsluttetDato',
            'avsluttetAv',
            'arkivperiodeStartDato',
            'arkivperiodeSluttDato',
            'referanseForloeper',
            'referanseArvtaker',
            ('kassasjon', self.recurse_xml_kassasjon),
            ('utfoertKassasjon', self.recurse_xml_utfoertKassasjon),
            ('sletting', self.recurse_xml_sletting),
            ('skjerming', self.recurse_xml_skjerming),
            ('gradering', self.recurse_xml_gradering),

            (klassifikasjonssystemrel, self.recurse_xml_klassifikasjonssystem),
            (mapperel, self.recurse_xml_mappe),
            (saksmapperel, self.recurse_xml_mappe),
            (registreringrel, self.recurse_xml_registrering),
        )
        self.recurse_xml_out_ordered(output, 'arkivdel', content, sequence)


    def recurse_xml_arkiv(self, output, content, first=False):
        underarkivrel = '%sarkivstruktur/underarkiv/' % self.relbaseurl
        arkivdelrel = '%sarkivstruktur/arkivdel/' % self.relbaseurl
        arkivskaperrel = '%sarkivstruktur/arkivskaper/' % self.relbaseurl
        oppbevrel = '%soppbevaringssted/' % self.nikitarelbaseurl

        # From n5v5 arkivstruktur.xsd:
        sequence = (
            'systemID',
            'oppdatertAv>[null]',
            'oppdatertDato>[null]',
            'tittel',
            'beskrivelse',
            'arkivstatus.kodenavn>arkivstatus',
            'arkivstatus.kode>[null]',
            'dokumentmedium.kodenavn>dokumentmedium',
            'dokumentmedium.kode>[null]',
            (oppbevrel, self.recurse_xml_oppbevaringssted), # FIXME for arkiv
            'opprettetDato',
            'opprettetAv',
            'avsluttetDato',
            'avsluttetAv',
            (arkivskaperrel, self.recurse_xml_arkivskaper),
            (underarkivrel,  self.recurse_xml_arkiv),
            (arkivdelrel,    self.recurse_xml_arkivdel),
        )
        attr = None
        if first:
            attr = 'xmlns="http://www.arkivverket.no/standarder/noark5/arkivstruktur" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"'
        self.recurse_xml_out_ordered(output, 'arkiv', content, sequence, attr=attr)


    def recurse_xml(self):
        try:
            self.login()
        except n5core.endpoint.LoginFailure:
            pass
        arkivhref = self.findRelation('%sarkivstruktur/arkiv/' % self.relbaseurl)
        (c, res) = self.json_get(arkivhref)
        arkivinfo = json.loads(c)

        utcnow = datetime.datetime.utcnow().replace(microsecond=0, tzinfo=pytz.utc).isoformat()
        if 'count' not in arkivinfo or 0 < arkivinfo['count']:
            for arkiv in arkivinfo['results']:
                self.savepath = 'uttrekk-%s/arkiv-%s-%s' % (
                    utcnow,
                    arkiv['systemID'],
                    arkiv['tittel'].replace('/', '_'))
                self._mkdir_recursive(self.savepath)
                with codecs.open('%s/arkivstruktur.xml' % self.savepath, 'w',
                                 encoding='UTF-8') as fh:
                    output = XMLFile(fh)
                    self.recurse_xml_arkiv(output, arkiv, first=True)


    def recurse(self):
        try:
            self.login()
        except n5core.endpoint.LoginFailure:
            pass
        print('Saving to %s' % self.savedir)
        urlsleft = ['.']
        urlseen = {}
        urlsrc = {'.': 'root'}
        while 0 < len(urlsleft):
            url = urlsleft.pop(0)
            if url in urlseen:
                continue
            urlseen[url] = 1

            path = url.replace(self.baseurl, '')
            path = path.rstrip('/').replace('/.', '/index')
            path = path + '.json'
            path = os.path.join(self.savedir, path)
            if -1 != path.find('//') or '/' == path[0]:
                print('error: bogus url %s seen in %s (path %s)' % ( url, urlsrc[url], path))
                continue

            try:
                if self.verbose:
                    print('info: Fetching %s' % url)
                else:
                    sys.stdout.write('.')
                    sys.stdout.flush()
                (content, res) = self.json_get(url)

                ctype = res.getheader('Content-Type')

                if self.verbose:
                    print('info: Creating %s for %s' % (path, url))
                dir = os.path.dirname(path)
                self._mkdir_recursive(dir)
                f = open(path, 'w')
                if 0 == ctype.find('application/vnd.noark5+json'):
                    j = json.loads(content)
                    f.write(json.dumps(j, indent=2))
                else:
                    f.write(content)
                f.close()

                if ctype is None:
                    print('error: No Content-Type from %s' % url)
                if ctype is None or 0 != ctype.find('application/vnd.noark5+json'):
                    print('info: ignoring %s' % url)
                else:
                    try:
                        baseref = j
                    except ValueError as e:
                        print('error: non-JSON content returned for %s' % url)
                        baseref = None
                    if baseref is None:
                        print('error: JSON MIME type but no JSON in %s' % url)
                    elif type(baseref) is list:
                        print('error: found json list in %s' % url)
                    elif '_links' in baseref:
                        for rel in baseref['_links'].keys():
                            if 'href' in baseref['_links'][rel]:
                                href = baseref['_links'][rel]['href']
                                if 'templated' in baseref['_links'][rel] and baseref['_links'][rel]['templated']:
                                    href = href.split('{')[0]
                                if href not in urlseen:
                                    urlsleft.append(href)
                                    if href not in urlsrc:
                                        urlsrc[href] = []
                                    urlsrc[href].append(url)
                    if baseref is not None and type(baseref) is not list:
                        for basekey in baseref.keys():
                            if basekey != '_links' and type(baseref[basekey]) is list:
                                for element in baseref[basekey]:
                                    if '_links' in element and len(element['_links'].keys()) > 0:
                                        for rel in element['_links'].keys():
                                            href = element['_links'][rel]['href']
                                            if href not in urlseen:
                                                urlsleft.append(href)
                                                if href not in urlsrc:
                                                    urlsrc[href] = []
                                                urlsrc[href].append(url)
            except HTTPError as e:
                pass
        if not self.verbose:
            print('')

def main():
    t = ContentDumper()
    if t.xml:
        return t.recurse_xml()
    else:
        return t.recurse()

if __name__ == '__main__':
    exit(main())
